---
title: "Turing Machine Cycle Detector"
description: "Explore the limits of `longerThan10`"
date: "2025-10-27"
date-format: long
author: Grant Anderson, Joseph Oforkansi, 
execute:
  echo: true
format:
  live-revealjs:
    completion: true
    theme: default
    css: ../../../css/styles.css
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    footer: "Proofgrammers"
---

# Introduction

::: {.fragment style="margin-top: -0.5em; font-size: 1em;"} 
- In this presentation, we explore the design and analysis of a **Python program** that determines whether the **state diagram of a Turing Machine (M)** contains cycles. A Turing Machine is a fundamental model of computation that defines the limits of what can be calculated. By detecting cycles in its state diagram, we can identify repeating or potentially infinite behaviors within a machine’s structure. This project bridges **theoretical computer science** and **practical programming**, showing how abstract models can be represented in real code.  

Beyond implementation, we analyze our program from two critical perspectives in computation theory:  
(a) whether the problem is **computable or uncomputable**, and  
(b) whether it is **tractable or intractable**.  

Through this analysis, we demonstrate that while many Turing Machine problems are undecidable, detecting cycles in a finite state diagram is both **computable** and **tractable**, revealing the deep connection between **mathematical theory** and **algorithmic design**.
:::

##  Problem Definition

::: {.fragment style="margin-top: 1.0em; font-size: 1.0em;"} 
- Given a Turing Machine \(M\), our goal is to determine whether the **state diagram** of \(M\) contains cycles.  
A cycle represents a sequence of transitions that returns to a previous state — suggesting **repetition or potential infinite looping**.  
Understanding whether such cycles exist helps illustrate the **structural behavior** of computation without running the machine on input.  
This provides insight into **decidable vs. undecidable** questions in computation.
:::

# Theoretical Background

::: {.fragment style="font-size: 1em;"}
- A **Turing Machine (TM)** is a mathematical abstraction that captures the essence of computation.  
- It consists of an infinite tape, read/write head, and a finite set of states governed by a **transition function**.  
- The concept of **computability** asks what problems can be solved by any TM, while **tractability** measures how efficiently they can be solved.  
- In this project, we focus on a **structural property**—the existence of cycles in the TM’s transition graph.
:::

# Turing Machine Cycle Detector

::: {.fragment style="font-size: 1em;"}
- {{< iconify fa6-solid arrow-right >}} **Transition Class:** Represents a single transition rule in the Turing Machine  
- {{< iconify fa6-solid gear >}} **TuringMachine Class:** Models a Turing Machine with states, symbols, and transitions  
- {{< iconify fa6-solid arrows-spin >}} **has_cycles():** Detects cycles using **Depth-First Search (DFS)** on the state diagram
:::

## Implementation

::: {.fragment style="margin-top: -0.5em; font-size: 0.8em;"} 
```{python}
from typing import Dict, Set, List, Tuple
from dataclasses import dataclass

@dataclass
class Transition:
    """Represents a transition in a Turing machine."""
    current_state: str
    read_symbol: str
    next_state: str
    write_symbol: str
    move_direction: str  # 'L' for left, 'R' for right

class TuringMachine:
    """Represents a Turing machine with its states and transitions."""
    
    def __init__(self):
        self.states: Set[str] = set()
        self.transitions: List[Transition] = []
        self.alphabet: Set[str] = set()
        self.initial_state: str = None
        self.accept_state: str = None
        self.reject_state: str = None

    def add_transition(self, transition: Transition):
        """Add a transition to the Turing machine."""
        self.states.add(transition.current_state)
        self.states.add(transition.next_state)
        self.alphabet.add(transition.read_symbol)
        self.alphabet.add(transition.write_symbol)
        self.transitions.append(transition)

def has_cycles(tm: TuringMachine) -> bool:
    """
    Determine if a Turing machine's state diagram contains cycles using DFS.
    Returns True if cycles are found, False otherwise.
    
    This is computable because we're only analyzing the static structure
    of the state diagram, not the machine's behavior on any input.
    
    Time Complexity: O(V + E) where V is number of states and E is number of transitions
    Space Complexity: O(V) for the visited set and recursion stack
    """
    def dfs(state: str, visited: Set[str], rec_stack: Set[str]) -> bool:
        # If state is in recursion stack, we found a cycle
        if state in rec_stack:
            return True
            
        # If already visited and not in recursion stack, no cycle here
        if state in visited:
            return False
            
        # Add state to both visited and recursion stack
        visited.add(state)
        rec_stack.add(state)
        
        # Check all transitions from current state
        for transition in tm.transitions:
            if transition.current_state == state:
                if dfs(transition.next_state, visited, rec_stack):
                    return True
                    
        # Remove state from recursion stack
        rec_stack.remove(state)
        return False

    visited: Set[str] = set()
    rec_stack: Set[str] = set()
    
    # Try DFS from each unvisited state
    for state in tm.states:
        if state not in visited:
            if dfs(state, visited, rec_stack):
                return True
                
    return False

def test_cycle_detection():
    """Test the cycle detection with example Turing machines."""
    # Example 1: TM with a cycle
    tm1 = TuringMachine()
    tm1.add_transition(Transition("q0", "1", "q1", "1", "R"))
    tm1.add_transition(Transition("q1", "1", "q2", "1", "R"))
    tm1.add_transition(Transition("q2", "1", "q0", "1", "R"))  # Creates cycle
    assert has_cycles(tm1) == True, "Failed to detect cycle in tm1"
    
    # Example 2: TM without cycles
    tm2 = TuringMachine()
    tm2.add_transition(Transition("q0", "1", "q1", "1", "R"))
    tm2.add_transition(Transition("q1", "1", "q2", "1", "R"))
    tm2.add_transition(Transition("q2", "1", "qaccept", "1", "R"))
    assert has_cycles(tm2) == False, "False positive cycle detection in tm2"
    
    print("All tests passed!")

if __name__ == "__main__":
    test_cycle_detection()
```
:::

## Computability and Tractablility

::: {.fragment style="margin-top: .75em; font-size: 1.0em;"} 

{{< iconify fa6-solid check >}} The program is computable.

- The program only analyzes the structure, not the actual output behavior based on inputs.

{{< iconify fa6-solid check >}} The program is tractable.

- Using the current depth first search, the time complexity is O(V*E).

:::

## 

::: {.fragment style="margin-top: 0em; font-size: 1.0em;"} 

:::

# 

::: {.fragment style="margin-top: 0.5em; font-size: 1.0em;"}

:::

::: {.fragment style="margin-top: 1.0em; font-size: 1.0em; font-weight: bold;"}

:::

