---
title: "Turing Machine Cycle Detector"
description: "Explore the limits of longerThan10"
date: "2025-10-27"
date-format: long
author: Grant Anderson, Joseph Oforkansi, Duru Akbas
execute:
  echo: true
format:
  live-revealjs:
    completion: true
    theme: default
    css: ../../../css/styles.css
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    footer: "Proofgrammers"
---

# Introduction

::: {.fragment style="margin-top: -0.5em; font-size: 1em;"} 
In this presentation, we explore a **Python program** that determines whether the **state diagram of a Turing Machine (M)** contains cycles. 

A Turing Machine is a fundamental model of computation that defines the limits of what can be calculated. By detecting cycles in its state diagram, we can identify repeating or potentially infinite behaviors within a machine’s structure.   

Beyond implementation, we analyze our program from two critical areas:  
(a) whether the problem is **computable or uncomputable**, and  
(b) whether it is **tractable or intractable**.  
:::

---

# Problem Definition

::: {.fragment style="font-size: 1em;"}
Given a Turing Machine \(M\), our goal is to determine whether the **state diagram** of \(M\) contains cycles.  
A cycle represents a sequence of transitions that returns to a previous state — suggesting **repetition or potential infinite looping**.  
Understanding whether such cycles exist helps illustrate the **structural behavior** of computation without running the machine on input.  
This provides insight into **decidable vs. undecidable** questions in computation.
:::

---

# Theoretical Background

::: {.fragment style="font-size: 1em;"}
- A **Turing Machine (TM)** is a mathematical abstraction that captures the essence of computation.  
- It consists of an infinite tape, read/write head, and a finite set of states governed by a **transition function**.  
- The concept of **computability** asks what problems can be solved by any TM, while **tractability** measures how efficiently they can be solved.  
- In this project, we focus on a **structural property**—the existence of cycles in the TM’s transition graph.
:::

---

# Turing Machine Cycle Detector

::: {.fragment style="font-size: 1em;"}
- {{< iconify fa6-solid arrow-right >}} **Transition Class:** Represents a single transition rule in the Turing Machine  
- {{< iconify fa6-solid gear >}} **TuringMachine Class:** Models a Turing Machine with states, symbols, and transitions  
- {{< iconify fa6-solid arrows-spin >}} **has_cycles():** Detects cycles using **Depth-First Search (DFS)** on the state diagram
:::

---

## Implementation

::: {.fragment style="margin-top: -0.5em; font-size: 0.8em;"} 
```{python}
from typing import Dict, Set, List, Tuple
from dataclasses import dataclass

@dataclass
class Transition:
    """Represents a transition in a Turing machine."""
    current_state: str
    read_symbol: str
    next_state: str
    write_symbol: str
    move_direction: str  # 'L' for left, 'R' for right

class TuringMachine:
    """Represents a Turing machine with its states and transitions."""
    
    def __init__(self):
        self.states: Set[str] = set()
        self.transitions: List[Transition] = []
        self.alphabet: Set[str] = set()
        self.initial_state: str = None
        self.accept_state: str = None
        self.reject_state: str = None

    def add_transition(self, transition: Transition):
        """Add a transition to the Turing machine."""
        self.states.add(transition.current_state)
        self.states.add(transition.next_state)
        self.alphabet.add(transition.read_symbol)
        self.alphabet.add(transition.write_symbol)
        self.transitions.append(transition)

def has_cycles(tm: TuringMachine) -> bool:
    """
    Determine if a Turing machine's state diagram contains cycles using DFS.
    Returns True if cycles are found, False otherwise.
    
    This is computable because we're only analyzing the static structure
    of the state diagram, not the machine's behavior on any input.
    
    Time Complexity: O(V + E) where V is number of states and E is number of transitions
    Space Complexity: O(V) for the visited set and recursion stack
    """
    def dfs(state: str, visited: Set[str], rec_stack: Set[str]) -> bool:
        # If state is in recursion stack, we found a cycle
        if state in rec_stack:
            return True
            
        # If already visited and not in recursion stack, no cycle here
        if state in visited:
            return False
            
        # Add state to both visited and recursion stack
        visited.add(state)
        rec_stack.add(state)
        
        # Check all transitions from current state
        for transition in tm.transitions:
            if transition.current_state == state:
                if dfs(transition.next_state, visited, rec_stack):
                    return True
                    
        # Remove state from recursion stack
        rec_stack.remove(state)
        return False

    visited: Set[str] = set()
    rec_stack: Set[str] = set()
    
    # Try DFS from each unvisited state
    for state in tm.states:
        if state not in visited:
            if dfs(state, visited, rec_stack):
                return True
                
    return False

def test_cycle_detection():
    """Test the cycle detection with example Turing machines."""
    # Example 1: TM with a cycle
    tm1 = TuringMachine()
    tm1.add_transition(Transition("q0", "1", "q1", "1", "R"))
    tm1.add_transition(Transition("q1", "1", "q2", "1", "R"))
    tm1.add_transition(Transition("q2", "1", "q0", "1", "R"))  # Creates cycle
    assert has_cycles(tm1) == True, "Failed to detect cycle in tm1"
    
    # Example 2: TM without cycles
    tm2 = TuringMachine()
    tm2.add_transition(Transition("q0", "1", "q1", "1", "R"))
    tm2.add_transition(Transition("q1", "1", "q2", "1", "R"))
    tm2.add_transition(Transition("q2", "1", "qaccept", "1", "R"))
    assert has_cycles(tm2) == False, "False positive cycle detection in tm2"
    
    print("All tests passed!")

if __name__ == "__main__":
    test_cycle_detection()
```
:::

# Visualizing a Cycle in a Turing Machine

::: {.fragment style="font-size: 1em;"}
To understand what it means for a Turing Machine to contain a **cycle**, consider the example below.
:::

---

### Example State Diagram

::: {.fragment style="font-size: 1.0em; font-family: monospace; background-color: #f6f8fa; padding: 1em; border-radius: 8px;"}
q0 --(1/R)--> q1  
q1 --(1/R)--> q2  
q2 --(1/R)--> q0   ← forms a **cycle**
:::

::: {.fragment style="font-size: 1em; margin-top: 1em;"}
- Each arrow represents a **transition** on symbol `1`, moving right (R).  
- Starting from `q0`, the machine returns to `q0` after a series of transitions.  
- This **loop** means the TM can potentially repeat these states indefinitely.
:::

---

### Visual Representation

::: {.fragment style="font-size: 1em;"}
If you include a diagram file, you can render it like this:
:::

```{r}
#| echo: false
#| fig-cap: "Cycle in Turing Machine State Diagram"
#| out-width: 70%
#| fig-align: center
# This is an optional placeholder if you want to include an image later
# knitr::include_graphics("cycle_diagram.png")
```

---

# Computability and Tractability Analysis

::: {.fragment style="margin-top: .75em; font-size: 1.0em;"} 

**Computability:**
Detecting cycles in a finite state diagram is decidable — the algorithm always halts since the number of states and transitions is finite.

**Tractability:**
The Depth-First Search runs in O(V + E) time, making the solution tractable (polynomial time).

This demonstrates that while many Turing Machine questions are undecidable, this structural problem is both computable and efficiently solvable.
:::

## Test cases

::: {.fragment style="margin-top: 0em; font-size: 1.0em;"} 
Here are some of the test cases for this code:

```{python}
tm1 = TuringMachine()
tm1.add_transition(Transition("q0", "1", "q1", "1", "R"))
tm1.add_transition(Transition("q1", "1", "q2", "1", "R"))
tm1.add_transition(Transition("q2", "1", "q0", "1", "R"))  # cycle here
print(has_cycles(tm1)) # expected output should be true
```
- This is a case where it goes until the 3rd state and comes back to "q0" where it started.
- q0 → q1 → q2 → q0
- The symbol `1` is just an example; what matters are the states and their transitions.

:::

# Test Case 2

::: {.fragment style="margin-top: 0.5em; font-size: 1.0em;"}

```{python}
tm2 = TuringMachine()
tm2.add_transition(Transition("q0", "1", "q1", "1", "R"))
tm2.add_transition(Transition("q1", "1", "q2", "1", "R"))
tm2.add_transition(Transition("q2", "1", "q3", "1", "R"))
print(has_cycles(tm2))  # expected output is False
```

- Linear chain — each state transitions to the next without looping back, so no cycles occur.
- q0 → q1 → q2 → q3

:::

# Test Case 3
::: {.fragment style="margin-top: 1.0em; font-size: 1.0em; font-weight: bold;"}

```{python}
tm3 = TuringMachine()
tm3.add_transition(Transition("q0", "1", "q0", "1", "R"))  # self-loop
print(has_cycles(tm3))  # expected output is True
```

- Self-loop => transitions to itself immediately
- q0 → q0
:::

# Conclusion
::: {.fragment style="margin-top: 1.0em; font-size: 1.0em; font-weight: bold;"}

-  The cycle detection problem in a Turing Machine’s states is a computable problem, since it only examines a finite set of states and transitions.

- The algorithm is tractable, running in O(V + E) time using Depth-First Search — efficient for real implementations.

- It does not require executing or simulating the Turing Machine, which avoids undecidable cases such as determining whether it accepts an input or halts on a given input.
